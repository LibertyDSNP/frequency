# Design Doc for P256 PassKey Support

## Table of Contents

- [Design Doc for P256 PassKey Support](#design-doc-for-p256-passkey-support)
  - [Table of Contents](#table-of-contents)
  - [1. Introduction](#1-introduction)
  - [2. Benefits](#2-benefits)
  - [3. Terminology](#3-terminology)
    - [Accounts](#accounts)
    - [Keys](#keys)
    - [Signatures](#signatures)
  - [4.1. Data Flow Diagram](#41-data-flow-diagram)
  - [4.2. Data maps for Legal Teams](#42-data-maps-for-legal-teams)
  - [5. Specification](#5-specification)
    - [Passkey Registration](#passkey-registration)
    - [Transaction Submission Specification](#transaction-submission-specification)
    - [Security Considerations](#security-considerations)
  - [6. Implementation](#6-implementation)
    - [Backend Example Code](#backend-example-code)
    - [Frontend Example Code](#frontend-example-code)
  - [7. Options for Discussion](#7-options-for-discussion)
    - [Unsigned Extensions vs Extending MultiSignature](#unsigned-extensions-vs-extending-multiSignature)
    - [Generic Key Support](#generic-key-support)
    - [Separate Pallet](#separate-pallet)
  - [8. Conclusion](#8-conclusion)

## 1. Introduction

This document outlines the design considerations and specifications for integrating P256 Passkey support for performing transactions on Frequency chain. Passkey support aims to provide a novel non custodial solution for managing user accounts and signing transactions on-chain.

## 2. Benefits

- **Non-Custodial Account Management**: Passkey support enables users to interact with Frequency chain without actual seed access. This reduces the risk of seed exposure and enhances security.

- **Functionality**: Passkey support provides a better user experience by enabling users to sign transactions without seed access. The poliferation of passkey enabled services can lead to a seamless user experience.

- **Interoperability**: The use of standard cryptographic protocols (e.g., P256) ensures compatibility with other systems and services that also support these standards. This can facilitate integrations with existing wallets, security modules, and third-party applications.

- **Backup and Recovery**: Passkey support can be used to facilitate account recovery and backup mechanisms. By signing the account public key, users can prove ownership of the account and recover access in case of loss of seed access.

## 3. Terminology

### Accounts

- **Passkey Account**: The user account associated with the Passkey.
- **Frequency Account**: The account used for on-chain transactions and interactions. This account is derived from a seed phrase generated by Frequency Access.
- **Frequency Access**: The platform facilitating the management and interaction with user accounts.

### Keys

- **Passkey**: P256 key pair used for transaction signing and account management. This is the primary key used for transaction signing.
- **Passkey Public Key**: The public key retrieved from the Passkey registration process.
- **Account Key**: The key pair generated from a seed phrase.
- **Account Public Key**: The public key derived from the Account Key.

### Signatures

- **Account signature on PassKey Public Key**: A cryptographic signature generated using the Account Key. The data being signed is passkey public key. This is used to prove ownership of Account Key.
- **Passkey Signatures**: A cryptographic signature generated using the Passkey private key. This is presented to passkey enabled services as a challenge-response mechanism. Passkeys are used to generate two signatures as follows:
  - **Signature on Account Public Key**: Passkey signs a message containing the account public key. This signature is retained by the Frequency Access platform and/or maybe used for account recovery.
  - **Signature on Transactions**: Passkey signs the transaction payload which needs to be submitted on-chain. This signature is used to verify the authenticity of the transaction.

## 4.1. Data Flow Diagram

- [Registration Diagram](https://docs.google.com/drawings/d/1x9pM2OVU0zNLVJWHvHhMzLfFnIpqYU2KNVDuDMgXnrY)
- [Transaction Diagram](https://docs.google.com/drawings/d/1eSgwxuCrR0x-J_7kzqnn-POXrZ5XCWM7TF0tyaxKKaw)

## 4.2. Data maps for Legal Teams

### Frequency Access backend
- PassKey Signature of Account public key (`passkey_sig_pk`)
- PassKey signature of transaction (`passkey_tx_signature`)
- Frequency Account key signature of Passkey public key (`account_sig_passkey_pk`)
- `credentialPublicKey`: Passkey Public key (`passkey_pk`)
- `UserName`: User's website-specific username (email, etc...)
- `UserId`: User's website-specific unique ID
- `CredentialId`: The credential's credential ID for the pass key
- `Counter`: The number of times the authenticator reported it has been used.
- `credentialDeviceType`: Whether this is a single-device or multi-device credential.
- `credentialBackedUp`: Whether or not the multi-device credential has been backed up. Always false for single-device credentials.
- Transaction call

### Users Device
- Keypair for PassKey
- Keypair seed backup for Frequency Account
- All data included in the [Frequency Access backend](#frequency-access-backend) section

## 5. Specification

These are the following technical terms and specifications for the implementation of Passkey support on Frequency chain.

- `account_keypair` : A cryptographic key pair generated from a seed phrase
- `account_pk` : Account Public Key
- `passkey_pk` : Passkey Public Key
- `passkey_sig_pk` : Signature generated by Passkey on  `account_pk`
- `account_sig_passkey_pk` : Signature generated by Account Key on `passkey_pk`
- `passkey_tx_signature` : Signature generated by Passkey on transaction payload, this is required for transaction submission.

### Passkey Registration

1. **User visits Frequency Access "Wallet Setup Page"**:
   - The browser JavaScript generates a seed phrase, using it to generate `account_keypair` and the corresponding account public key (`account_pk`).

2. **Frequency Access requests creation of user Passkey**:
   - A challenge containing the `account_pk` is sent to the Passkey generation process.

3. **Browser JavaScript handles Passkey creation**:
   - The Passkey generation process creates a Passkey and provides the `passkey_pk`.
   - The Passkey signs the `account_pk`, resulting in `passkey_sig_pk`.

4. **Browser JavaScript generates a signature using the seed phrase**:
   - `account_keypair` is used to generate a signature on the `passkey_pk`, resulting in `account_sig_passkey_pk`.

      ```javascript
        // Generate Account Key Pair
        const mnemonic = "GENERATE SOME MNEMONIC HERE"
        const keyring = new Keyring({ type: 'sr25519' });
        const account_keypair = keyring.addFromMnemonic(mnemonic);
        ...
        ...
        const account_pk = account_keypair.publicKey;

        // Generate Passkey and Sign Account Public Key
        const options = generateRegistrationOptions();
        options.challenge = account_pk;
        const registerPassKey = await SimpleWebAuthnBrowser.startRegistration(options);
        ...
        ...
        // Sign Passkey Public Key using Account Key
        const passkey_sig_pk = registerPassKey.signature; // obtained from the registration response
        const passkey_pk = registerPassKey.publicKey; // obtained from the registration response

        // Sign Passkey Public Key using Account Key, this is used to prove ownership of the account
        const account_sig_passkey_pk = account_keypair.sign(passkey_pk);
      ```

5. **Backup options offered to the user**:
   - The user is prompted to download the seed phrase or backup the seed phrase to a secure location.

6. **Browser JavaScript transfers information to Frequency Access Backend**:
   - The following data is sent:
     - `passkey_pk`
     - `account_pk`
     - `account_sig_passkey_pk`
     - `passkey_sig_pk`

7. **Frequency Access validates and stores the data**:
   - The backend validates the signatures to ensure ownership and integrity.
   - The backend stores the following:
     - `passkey_pk`
     - `account_pk`
     - `account_sig_passkey_pk`
     - Optionally, `passkey_sig_pk` can be stored for account recovery.

### Transaction Submission Specification

Browser/Client receives the following data from the backend:

- `passkey_pk`
- `account_pk`
- `account_sig_passkey_pk`

1. **Transaction Formation**:
   - The client initiates a transaction by providing the details needed for the transaction (e.g., recipient address, amount, nonce).
   - The transaction payload includes the actual tx and proof of account ownership.

    ```javascript
        // Form the transaction payload

        // an example transaction
        const tx = api.tx.balances.transfer(..., ...);

        // Prepare the passkey payload to be signed by Passkey
        const account_ownership_proof = {
          Sr25519: account_sig_passkey_pk,
        };

        let passkeyCallData = {
          accountId: account_pk,
          accountOwnershipProof: account_ownership_proof,
          call: tx,
        };

        let passkeyCall = api.registry.createType('PalletFrequencyTxPaymentPasskeyCall', passkeyCallData);
    ```

2. **Passkey Signing**:
   - The transaction payload is sent to the Passkey for signing.
   - The Passkey signs the transaction payload using its private key, producing a `passkey_tx_signature`.

    ```javascript

      // Sign the passkeyCall payload using Passkey
      const passkeyTxSignature = await SimpleWebAuthnBrowser.startAssertion({
        challenge: passkeyCall.toU8a(),
        // Additional options
      });

      // The signature generated by Passkey
      passkey_tx_signature = passkeyTxSignature.signature;
      passkey_authenticator_data = passkeyTxSignature.authenticatorData;
      passkey_client_data = passkeyTxSignature.clientData;
      //
    ```

3. **Transaction Submission**:
   - The transaction payload, that requires, `passkey_pk`, `passkey_tx_signature`, `passkey_authenticator_data`, `passkey_client_data` is submitted to the chain.
   - The transaction is submitted to the chain as in `unsigned` extrinsic.

    ```javascript
      // Prepare the payload for the passkey proxy call
      let payload = {
        passkeyPublicKey: Array.from(passkey_pk),
        passkeySignature: Array.from(base64UrlToUint8Array(passkey_tx_signature)),
        passkeyAuthenticator: Array.from(base64UrlToUint8Array(passkey_authenticator_data)),
        passkeyClientDataJson: Array.from(base64UrlToUint8Array(
          passkey_client_data)),
        passkeyCall,
      };

      const passkey_payload = api.createType('PalletFrequencyTxPaymentPasskeyPayload', payload);

      // Submit the transaction to the chain without signature
      const tx = api.tx.{frequecyPassKeyProxy}.submitPasskeyTx(passkey_payload);
      await tx.send()
    ```

4. **Backend Validation and Submission**:

### Security Considerations

#### Generic
- Never store or backup the seed phrase other than memory.
- Prefer more client side data processing and handling, backend should only store the necessary data.
- Choose vetted libraries, npm packages for handling cryptographic operations, such that signing with seed phrase, or handling of private keys is done securely.

#### Front-end (client)
- If key generation is done in front-end, it should ideally being done inside an isolated section such as iframe or Web Worker.
- Generated Keypair should not get stored permanently (except for back up options) and removed as soon as it is not required.

#### Backend
- Passkey registration response should get verified which checks the random challenge
- Passkey Login response should get verified which checks the random challenge
- Passkey Transaction response should get verified which checks transaction related challenge.
- Any provided Frequency account signature should get verified.

#### On-chain
- Preferably using an audited crate to support p256 operations. Currently, we are using `p256` crate
  which is not audited.
- If signature checks implemented **on_validate** are expensive, then this would open a vulnerability
  surface for DOS attacks.

## 6. Implementation

### Backend Example Code

#### Passkey Registration Verification
```typescript
    // RegistrationResponseJSON is the data that passkey authenticator returns after registeration
    const verification = await verifyRegistrationResponse({
        response: body as RegistrationResponseJSON,
        // challenge that server expects and provided for registeration
        expectedChallenge: currentChallenge,
        expectedOrigin: origin,
        expectedRPID: rpID,
        requireUserVerification: true,
    });

    if (verification.verified && verification.registrationInfo) {
        const { credentialPublicKey, credentialID, counter } = verification.registrationInfo;
        const transportsString = JSON.stringify(body.response.transports);
        await credentialService.saveNewCredential(
            loggedInUserId,
            credentialID,
            credentialPublicKey,
            counter,
            transportsString,
        );
    }
```

#### Transaction Authentication Verification
```typescript
    // get AuthenticatorDevice data from database by credentialId
    const dbCredential: AuthenticatorDevice | null = await credentialService.getCredentialByCredentialId(credentialId);
    const authenticator: VerifyAuthenticationResponseOpts["authenticator"] = {
        ...dbCredential,
        credentialID: credentialId,
    };
    const opts: VerifyAuthenticationResponseOpts = {
        response: body,
        expectedChallenge: currentChallenge,
        expectedOrigin: origin,
        expectedRPID: rpID,
        authenticator,
    };
     let verification: VerifiedAuthenticationResponse = await verifyAuthenticationResponse(opts);
    const { verified, authenticationInfo } = verification;

    if (verified) {
        // transaction authentication verification is successful
    }
```

#### Signature verification
- Non-optimal approach
```rust
	pub fn check_passkey_signature(
		payload: &PasskeyPayload<T>,
	) -> Result<(), TransactionValidityError> {
		// deserialize to COSE key format and check the key
		let cose_key = CoseKey::from_slice(&payload.passkey_public_key[..]);
		let (_, x) = cose_key
			.params
			.iter()
			.find(|(l, _)| l == &Label::Int(-2));
		let (_, y) = cose_key
			.params
			.iter()
			.find(|(l, _)| l == &Label::Int(-3));

		// convert COSE format to P256 verifying key
		let encoded_point =
			EncodedPoint::from_affine_coordinates(
				GenericArray::from_slice(&x.clone().into_bytes()),
				GenericArray::from_slice(&y.clone().into_bytes()),
				false,
			);
		let verify_key = p256::ecdsa::VerifyingKey::from_encoded_point(&encoded_point);

		let passkey_signature =
			p256::ecdsa::DerSignature::from_bytes(&payload.passkey_signature[..]);

		// extract the challenge from client_data and
		// ensure the that the challenge is the same as the call payload
		let client_data: serde_json::Value =
			serde_json::from_slice(&payload.passkey_client_data_json);
		let extracted_challenge = match client_data {
			serde_json::Value::Object(m) => {
				let challenge = m
					.get(&"challenge".to_string());
				if let serde_json::Value::String(base64_url_encoded) = challenge {
					let decoded = base64_url::decode(&base64_url_encoded).map_err(|_| {
						TransactionValidityError::Invalid(InvalidTransaction::Custom(9))
					})?;
					Ok(decoded)
				}
			},
			_ => Err(TransactionValidityError::Invalid(InvalidTransaction::Custom(11))),
		}?;

		let encoded_payload = payload.passkey_call.encode();
		ensure!(
			encoded_payload == extracted_challenge,
			TransactionValidityError::Invalid(InvalidTransaction::Custom(12))
		);

		// prepare signing payload which is [authenticator || sha256(client_data_json)]
		let mut passkey_signature_payload = payload.passkey_authenticator.to_vec();
		passkey_signature_payload.extend_from_slice(&sha2_256(&payload.passkey_client_data_json));

		// finally verify the passkey signature against the payload
		verify_key
			.verify(&passkey_signature_payload, &passkey_signature)
	}
```
- Some possible optimizations
    - **Compressed public key**: Currently passed public key is in **Cose** format, and it's between 70-73 bytes.
      If the client can parse the Cose public key can extract the compressed encoded key. This public key can
      get reduced to 33 bytes.
    - **Challenge data deduplication**: Currently the challenge data is duplicated in `expected_challenge` and
      in it's serialized format inside `passkey_client_data_json`. If the client is able to parse
      `passkey_client_data_json` and replace `challenge` field value with empty string. Then during the
      signature check we can replace that empty string with `expected_challenge` and that would allow us to
      reduce the transaction size by around **40%**. It is important that the order of the field `passkey_client_data_json`
      does not change during this operation since that would generate a different signature.

## 7. Options for Discussion

### Unsigned Extensions vs Extending MultiSignature

#### Unsigned Extensions
In this variant we will have an unsigned extrinsic and all the related checks would be done inside
`ValidateUnsigned` trait implementation for the pallet.

##### Pros/Cons
- **Pro**: Faster and already proven implementation
- **Pro**: Flexibility to be replaced with other implementations
- **Con**: Some duplication of code between existing checks on signed extensions and the checks
  implemented on `ValidateUnsigned`
- **Con**: An unsigned extrinsic implementation might open up a new unknown attack vector.

#### Extending MultiSignature
In this variant we will extend `MultiSignature` enum and replace it with a new enum which will have
a new `P256` signature type.

##### Pros/Cons
- **Pro**: No need to use unsigned extrinsic and all extra checks would be done inside a new signed
  extension.
- **Pro**: A uniform and generic solution which would allow having P256 signature scheme to be used
  for other operations on chain.
- **Pro**: This would allow us to use P256 accounts to hold token (but that might not be desirable)
- **Pro**: We could use the P256 keys as MSA control keys.
- **Con**: Requires significant effort (in case if no hard constraints detected) to implement compared to using
  unsigned extension and once deployed there would not be an easy way for a backwards compatible rollback.
  Here is a quick breakdown for known issues:
    - Signature size mismatch force us to implement a new `Signature` type with all required traits.
    - Public key size mismatch might force us to implement a new `Publickey` type with all required traits.
    - Reimplementing `MultiSignature`, `MultiSigner` and other types with `P265` functionality added.
    - Adding signature and key generation support on polkadotJS and all frontend implementations
    - Might require DB migration for already stored MultiSignatures


### Generic Key Support
There is an issue with the `account_key` generation flow since it would only support transactions
that do not require any Msa account. To be able to use the PassKey feature for the majority of
transactions, it might be better if the `account_key` was already in a wallet and the Msa account
was created for that key,and we register a passkey using the same.

### Separate Pallet
_Question_: Should we implement this feature in a separate pallet or just use already existing `frequency-tx-payment`
pallet?

One argument against having it in a separate pallet is since there is no extra data required to be
stored on-chain, it seems less necessary to split it into a separate pallet.
Another argument in favor of having it in a new pallet is to be able to share this pallet with other
para-chains in the Polkadot ecosystem.
## 8. Conclusion

(Summarize the key points of the design document and outline next steps for implementation and further discussion.)
